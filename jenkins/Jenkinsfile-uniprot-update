import groovy.json.JsonSlurper
// This Jenkinsfile is used by Jenkins to run the 'UniProt Update' step of Reactome's release.
// This step synchronizes Reactome's database with UniProt. 
// It requires that the 'ConfirmReleaseConfigs' step has been run successfully before it can be run.
def currentRelease
def previousRelease
pipeline {
	agent any

	stages {
		// This stage checks that an upstream step, ConfirmReleaseConfigs, was run successfully.
		stage('Check ConfirmReleaseConfigs build succeeded'){
			steps{
				script{
					// Get current release number from directory
					currentRelease = (pwd() =~ /Releases\/(\d+)\//)[0][1];
					previousRelease = (pwd() =~ /Releases\/(\d+)\//)[0][1].toInteger() - 1;
					// This queries the Jenkins API to confirm that the most recent build of ConfirmReleaseConfigs was successful.
					def configStatusUrl = httpRequest authentication: 'jenkinsKey', validResponseCodes: "${env.VALID_RESPONSE_CODES}", url: "${env.JENKINS_JOB_URL}/job/${currentRelease}/job/ConfirmReleaseConfigs/lastBuild/api/json"
					if (configStatusUrl.getStatus() == 404) {
						error("ConfirmReleaseConfigs has not yet been run. Please complete a successful build.")
					} else {
						def configStatusJson = new JsonSlurper().parseText(configStatusUrl.getContent())
						if (configStatusJson['result'] != "SUCCESS"){
							error("Most recent ConfirmReleaseConfigs build status: " + configStatusJson['result'] + ". Please complete a successful build.")
						}
					}
				}
			}
		}
		/*
		// This stage backs up the gk_central database before it is modified.
		stage('Setup: Back up gk_central before modifications'){
			steps{
				script{
					withCredentials([usernamePassword(credentialsId: 'mySQLCuratorUsernamePassword', passwordVariable: 'pass', usernameVariable: 'user')]){
						def central_before_uniprot_update_dump = "${env.GK_CENTRAL_DB}_${currentRelease}_before_uniprot_update.dump"
						sh "mysqldump -u$user -p$pass -h${env.CURATOR_SERVER} ${env.GK_CENTRAL_DB} > $central_before_uniprot_update_dump"
						sh "gzip -f $central_before_uniprot_update_dump"
					}
				}
			}
		}
		// Download uniprot_sprot.xml.gz and uniprot-reviewed:no.list.gz from UniProt.
		stage('Setup: Download uniprot_sprot.xml.gz and uniprot-reviewed:no.list.gz'){
			steps{
				script{
					sh "wget -q -N ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.xml.gz"
					sh "wget -q -O uniprot-reviewed:no.list.gz 'http://www.uniprot.org/uniprot/?query=reviewed%3Ano&compress=yes&format=list'"
					sh "mv uniprot*gz ${env.ABS_RELEASE_PATH}/uniprot_update/"
				}
			}
		}
		// This stage executes the UniProt Update Perl script. 
		stage('Main: UniProt Update'){
			steps {
				script{
					dir("${env.ABS_RELEASE_PATH}/uniprot_update/") {
						withCredentials([usernamePassword(credentialsId: 'mySQLCuratorUsernamePassword', passwordVariable: 'pass', usernameVariable: 'user')]){
							sh "perl uniprot_xml2sql_isoform.pl -db ${env.GK_CENTRAL_DB} -host ${env.CURATOR_SERVER} -user $user -pass $pass > uniprot.out 2> uniprot.err"
						}
					}
				}
			}
		}
		// This stage backs up the gk_central database after modification.
		stage('Post: Backup gk_central after modifications'){
			steps{
				script{
					withCredentials([usernamePassword(credentialsId: 'mySQLCuratorUsernamePassword', passwordVariable: 'pass', usernameVariable: 'user')]){
						def central_after_update_uniprot_update_dump = "${env.GK_CENTRAL_DB}_${currentRelease}_after_uniprot_update.dump"
						sh "mysqldump -u$user -p$pass -h${env.CURATOR_SERVER} ${env.GK_CENTRAL_DB} > $central_after_update_uniprot_update_dump"
						sh "gzip -f $central_after_update_uniprot_update_dump"
					}
				}
			}
		}
		*/
		// This stage emails the uniprot.wiki file to the default recipients list.
		stage('Post: Email UniProt.wiki file'){
			steps{
				script{
					emailext (
						body: "Hello,\n\nThis is an automated message from Jenkins regarding an update for v${currentRelease}. The UniProt Update step has completed. Please review the uniprot.wiki file attached to this email. If it looks correct, the contents of the file need to be uploaded to https://devwiki.reactome.org/index.php/Reports_Archive under 'UniProt Update Reports'. Please add the current UniProt wiki URL to the 'Archived reports' section of the page. If the file looks incorrect, please email the developer running Release. \n\nThanks!",
						to: '$DEFAULT_RECIPIENTS',
						from: "${env.JENKINS_RELEASE_EMAIL}",
						subject: "UniProt Update Reports for v${currentRelease}",
						attachmentsPattern: "**/${env.ABS_RELEASE_PATH}/uniprot_update/uniprot.wiki"
					)
				}
			}
		}
		// All databases, logs, and data files generated by this step are compressed before moving them to the Reactome S3 bucket. 
		// All files are then deleted.
		/*
		stage('Post: Archive Outputs'){
			steps{
				script{
					def s3Path = "${env.S3_RELEASE_DIRECTORY_URL}/${currentRelease}/uniprot_update"
					sh "mkdir -p databases/ data/ logs/"
					sh "mv --backup=numbered *_${currentRelease}_*.dump.gz databases/"
					sh "mv *.txt data/"
					sh "mv ${env.ABS_RELEASE_PATH}/uniprot_update/trembl_to_update.acc data/"
					sh "mv ${env.ABS_RELEASE_PATH}/uniprot_update/uniprot-reviewed:no.list data/"
					sh "mv ${env.ABS_RELEASE_PATH}/uniprot_update/uniprot_sprot.xml data/"
					sh "mv ${env.ABS_RELEASE_PATH}/uniprot_update/uniprot.wiki data/"
					sh "mv ${env.ABS_RELEASE_PATH}/uniprot_update/uniprot.* logs/"
					sh "gzip data/* logs/*"
					sh "aws s3 --no-progress --recursive cp databases/ $s3Path/databases/"
					sh "aws s3 --no-progress --recursive cp logs/ $s3Path/logs/"
					sh "aws s3 --no-progress --recursive cp data/ $s3Path/data/"
					sh "rm -r databases logs data"
				}
			}
		} 
		*/
	}
}
